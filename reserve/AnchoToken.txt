// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// import OpenZeppelin contracts
// import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Pausable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {OFT} from "@layerzero/contracts/token/oft/v1/OFT.sol";

contract AnchoToken is OFT, ERC20Pausable {
    // constants
    uint256 public constant MAX_SUPPLY = 777_777_777 * 10 ** 18;
    // tax configuration
    uint256 public constant MAX_TAX = 300; // 3% in basis points (100 = 1%)
    uint256 public taxRate = 200; // 2% in basis point

    // tax destination
    address public treasuryWallet;
    address public drawVault;

    // events for transparency
    event TaxRateUpdated(uint256 newTakRate);
    event TaxDistributed(uint256 treasuryAmount, uint256 drawVaultAmount);

    constructor(
        address _lzEndpoint, // layerZero endpoint address
        address initialOwner,
        address _treasuryWallet,
        address _drawVault
    ) OFT("AnchoToken", "ANCHO", _lzEndpoint) {
        // set tax destinations
        treasuryWallet = _treasuryWallet;
        drawVault = _drawVault;

        // transfer ownership to initial owner
        _transferOwnership(initialOwner);

        // mint the entire supply to the owner
        _mint(initialOwner, MAX_SUPPLY);
    }

    // override the _update function to apply tax on transfers
    function _update(
        address from,
        address to,
        uint256 value
    ) internal override(OFT, ERC20Pausable) {
        // no tax applied in these cases:
        // - minting (from is zero address)
        // - burning (to is zero address)
        // - transfers to/from treasury or vault (avoid double taxation)
        if (from == address(0) || to == address(0) || taxRate == 0) {
            super._update(from, to, value);
            return;
        }

        // calculate tax amount - 2% tax
        uint256 taxAmount = (value * taxRate) / 10000;
        uint256 transferAmount = value - taxAmount;

        // transfer the amount minus tax to recipient
        super._update(from, to, transferAmount);

        // distribute tax - 1% to each destination
        uint256 halfTax = taxAmount / 2;
        super._update(from, treasuryWallet, halfTax);
        super._update(from, drawVault, taxAmount - halfTax); // handle odd numbers

        emit TaxDistributed(halfTax, taxAmount - halfTax);
    }

    // function to update tax rate - adjustable up to 3%
    function setTaxRate(uint256 newTaxRate) external onlyOwner {
        require(newTaxRate <= MAX_TAX, "Tax rate too high");
        taxRate = newTaxRate;
        emit TaxRateUpdated(newTaxRate);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
