// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// layerZero OFT standard
interface IOFT {
    function sendFrom(
        address _from,
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint _amount,
        address _zroPaymentAddress,
        bytes calldata _adapterParams
    ) external payable;

    function estimateSendFee(
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) external view returns (uint nativeFee, uint zroFee);
}

// production LayerZero Bridge
contract Bridge is Ownable {
    IOFT public oftToken;

    // bridge configuration
    uint256 public constant BRIDGE_LIMIT = 7_000_000 * 10 ** 18;
    uint256 public totalBridged;

    // layerZero chain IDs
    uint16 public constant BASE_CHAIN_ID = 184;
    uint16 public constant ETHEREUM_CHAIN_ID = 101;

    mapping(bytes32 => bool) public processedTransactions;

    event TokensBridged(
        address indexed user,
        uint16 destChainId,
        uint256 amount,
        uint256 totalBridged
    );
    event BridgeLimitUpdated(uint256 newTotalBridged);

    constructor(address _oftToken, address initialOwner) Ownable(initialOwner) {
        oftToken = IOFT(_oftToken);
    }

    /**
     * @notice Bridge tokens to another chain using LayerZero OFT
     * @param amount Amount of tokens to bridge
     * @param destChainId LayerZero chain ID (184 for Base, 101 for Ethereum)
     */
    function bridgeTokens(uint256 amount, uint16 destChainId) external payable {
        require(amount > 0, "Amount must be positive");
        require(totalBridged + amount <= BRIDGE_LIMIT, "Bridge limit exceeded");
        require(
            destChainId == BASE_CHAIN_ID || destChainId == ETHEREUM_CHAIN_ID,
            "Invalid chain"
        );

        // update bridge state BEFORE transfer to prevent reentrancy
        totalBridged += amount;

        // use LayerZero OFT to send tokens
        bytes memory toAddress = abi.encodePacked(msg.sender);
        oftToken.sendFrom{value: msg.value}(
            msg.sender,
            destChainId,
            toAddress,
            amount,
            address(0), // ZRO payment address
            bytes("") // adapter parameters
        );

        emit TokensBridged(msg.sender, destChainId, amount, totalBridged);
    }

    /**
     * @notice estimate bridge fee
     */
    function estimateBridgeFee(
        uint16 destChainId,
        uint256 amount
    ) external view returns (uint256 nativeFee) {
        bytes memory toAddress = abi.encodePacked(msg.sender);
        (nativeFee, ) = oftToken.estimateSendFee(
            destChainId,
            toAddress,
            amount,
            false,
            bytes("")
        );
        return nativeFee;
    }

    /**
     * @notice admin function to update bridge state (for reconciliation)
     */
    function updateBridgedAmount(uint256 newTotalBridged) external onlyOwner {
        require(newTotalBridged <= BRIDGE_LIMIT, "Cannot exceed bridge limit");
        totalBridged = newTotalBridged;
        emit BridgeLimitUpdated(newTotalBridged);
    }

    /**
     * @notice emergency withdrawal of native currency (if any gets stuck)
     */
    function withdrawNative(
        address payable to,
        uint256 amount
    ) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient balance");
        to.transfer(amount);
    }

    function getRemainingCapacity() external view returns (uint256) {
        return BRIDGE_LIMIT - totalBridged;
    }

    function isBridgeLimitReached() external view returns (bool) {
        return totalBridged >= BRIDGE_LIMIT;
    }

    // accept native currency for fees
    receive() external payable {}
}
